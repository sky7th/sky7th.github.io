---
layout: post
title:  "[알고리즘 문제 해결 전략] 08. 동적 계획법"
subtitle:   "[알고리즘 문제 해결 전략] 08. 동적 계획법"
categories: book
tags: jongman
---

## 메모이제이션 패턴  
```cpp
int cache[2500][2500];
int someObscureFunction(int a, int b) {
    if(...) 
        return ...;
    int& ret = cache[a][b];
    if(ret != -1) 
        return ret;
    // 답 계산
    ...
    ...
    return ret;
}
int main() {
    memset(cache, -1, sizeof(cache));
}
```

## 예제: 외발 뛰기 (하)

> 칸 숫자만큼 오른쪽 or 아래로 점프, 마지막 도달 가능 ?

재귀함수
```cpp
int n, board[100][100];
bool jump(int y, int x) {
    if(y >= n || x >= n) return false;
    if(y == n-1 && x == n-1) return true;
    int jumpSize = board[y][x];
    return jump(y + jumpSize, x) || jump(y, x + jumpSize);
}
```

동적 계획법  
```cpp
int n, board[100][100];
int cache[100][100];
int jump2(int y, int x) {
    if(y >= n || x >= n) return 0;
    if(y == n-1 && x == n-1) return 1;
    int& ret = cache[y][x];
    if(ret != -1) return ret;
    int jumpSize = board[y][x];
    return ret = jump2(y + jumpSize, x) || jump2(y, x + jumpSize);
}
```

## 8.2 문제: 와일드카드 (중)

he?p = help, *p = help = cap  
와일드카드 패턴에 대응되는 문자열 찾기


완전 탐색
```cpp
bool match(const string& w, const string& s) {
    int pos = 0;
    while(pos < w.size() && pos < s.size() && (w[pos] == '?' || w[pos] == s[pos]))
        ++pos;
    if(pos == w.size())
        return pos == s.size();
    if(w[pos] == '*')
        for(int skip = 0; pos+skip <= s.size(); ++skip)
            if(match(w.substr(pos+1), s.substr(pos+skip)))
                return true;
    return false;
}
```

동적 계획법  
```cpp
int cache[101][101];
string W, S;
bool matchMemorized(int w, int s) {
    int ret& = cache[w][s];
    if(ret != -1) return ret;
    while(s < S.size && w < w< W.size() && (W[w] == '?' || W[w] == S[s]) {
        ++w;
        ++s;
    }
    if(w == W.size()) return ret = (s == S.size());
    if(W[w] == '*')
        for(int skip = 0; skip+s <= S.size(); ++skip)
            if(matchMemorized(w+1, s+skip))
                return ret = 1;
    return ret = 0;

}
```

#### 최적화 문제란?
> 여러개의 가능한 답 중 가장 좋은 답(최적해)을 찾아내는 문제

## 예제: 삼각형 위의 최대 경로 (하)  
> 직각 삼각형 -> 아래, 오른쪽 이동 가능  
> 모든 경로 중 숫자 합 최대화하는 경로는 ? 합은 ?

```cpp
int n, triangle[100][100];
int cache[100][100];
int path(int y, int x) {
    if(y == n-1) return triangle[y][x];
    int& ret = cache[y][x];
    if(ret != -1) return ret;
    return ret = max(path(y+1, x), path(y+1, x+1)) + triangle[y][x];
}
```
완전 탐색 꼴이 되지 않도록 조심하자

#### 최적 부분 구조  
> 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있는 경우의 구조

## 예제: 최대 증가 부분 수열 (하)

완전 탐색  
```cpp
int lis(const vector<int>& A) {
    if(A.empty()) return 0;
    int ret = 0;
    for(int i = 0; i < A.size(); ++i) {
        vector<int> B;
        for(int j = i+1; j < A.size(); ++j)
            if(A[i] < A[j])
                B.push_back(A[j]);
        ret = max(ret, 1 + lis(B));
    }
    return ret;
}
```

동적 계획법  
```cpp
int n;
int cache[100], S[100];
int lis(int start) {
    int& ret = cache[start];
    if(ret != -1) return ret;
    ret = 1;
    for(int next = start+1; next < n; ++next)
        if(S[start] < S[next])
            ret = max(ret, lis(next) + 1);
    return ret;
}
int maxLen = 0;
for(int begin = 0; begin < n; ++begin)
    maxLen = max(maxLen, lis(begin));
```

## 8.5 문제: 합친 LIS (하)

> '1 9 4'와 '3 4 7' -> '1 3 4 7 9'

